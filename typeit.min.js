// TypeIt by Alex MacArthur - https://typeitjs.com
!function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).TypeIt = t()
}(this, (function() {
    "use strict";
    var e = e => Array.isArray(e),
        t = t => e(t) ? t : [t];
    var n = e => Array.from(e),
        r = e => document.createTextNode(e);
    let i = e => ([...e.childNodes].forEach((e => {
        if (e.nodeValue)
            return [...e.nodeValue].forEach((t => {
                e.parentNode.insertBefore(r(t), e)
            })), void e.remove();
        i(e)
    })), e);
    var l = e => {
        let t = document.implementation.createHTMLDocument();
        return t.body.innerHTML = e, i(t.body)
    };
    const a = "ti-cursor",
        o = {
            started: !1,
            completed: !1,
            frozen: !1,
            destroyed: !1
        },
        s = {
            breakLines: !0,
            cursor: !0,
            cursorChar: "|",
            cursorSpeed: 1e3,
            deleteSpeed: null,
            html: !0,
            lifeLike: !0,
            loop: !1,
            loopDelay: 750,
            nextStringDelay: 750,
            speed: 100,
            startDelay: 250,
            startDelete: !1,
            strings: [],
            waitUntilVisible: !1,
            beforeString: () => {},
            afterString: () => {},
            beforeStep: () => {},
            afterStep: () => {},
            afterComplete: () => {}
        };
    function u(e, t=!1) {
        let n,
            r = document.createTreeWalker(e, NodeFilter.SHOW_ALL, {
                acceptNode: e => {
                    var t;
                    return (null == (t = e.classList) ? void 0 : t.contains(a)) ? NodeFilter.FILTER_REJECT : NodeFilter.FILTER_ACCEPT
                }
            }),
            i = [];
        for (; n = r.nextNode();)
            n.originalParent = n.parentNode,
            i.push(n);
        return t ? i.reverse() : i
    }
    function d(e, t=!0) {
        return t ? u(l(e)) : n(e).map(r)
    }
    var c = e => document.createElement(e),
        f = (e, t="") => {
            let n = c("style");
            n.id = t,
            n.appendChild(r(e)),
            document.head.appendChild(n)
        },
        h = t => (e(t) || (t = [t / 2, t / 2]), t),
        y = (e, t) => Math.abs(Math.random() * (e + t - (e - t)) + (e - t));
    let p = e => e / 2;
    var m = e => "value" in e;
    let g = e => "function" == typeof e ? e() : e;
    var b = e => Number.isInteger(e);
    let v = (e, t=document, n=!1) => t["querySelector" + (n ? "All" : "")](e);
    var w = (e, t) => Object.assign({}, e, t),
        T = e => {
            if (!e)
                return;
            let t = e.parentNode;
            (t.childNodes.length > 1 ? e : t).remove()
        };
    let S = {
        "font-family": "",
        "font-weight": "",
        "font-size": "",
        "font-style": "",
        "line-height": "",
        color: "",
        "margin-left": "-.125em",
        "margin-right": ".125em"
    };
    var E = (e, t) => new Array(t).fill(e);
    const L = ({queueItems: e, selector: t, cursorPosition: n, to: r}) => {
        if (b(t))
            return -1 * t;
        let i = new RegExp("END", "i").test(r),
            l = t ? [...e].reverse().findIndex((({char: e}) => {
                let n = e.parentElement,
                    r = n.matches(t);
                return !(!i || !r) || r && n.firstChild.isSameNode(e)
            })) : -1;
        return l < 0 && (l = i ? 0 : e.length - 1), l - n + (i ? 0 : 1)
    };
    let N = e => new Promise((t => {
            requestAnimationFrame((async () => {
                t(await e())
            }))
        })),
        M = e => {
            var t;
            return null == (t = e.func) ? void 0 : t.call(globalThis)
        },
        D = async (e, t, n) => {
            let r = t[e][1],
                i = [],
                l = e,
                a = r,
                o = () => a && !a.delay;
            for (; o();)
                i.push(a),
                o() && l++,
                a = t[l] ? t[l][1] : null;
            return i.length ? (await N((async () => {
                for (let e of i)
                    await M(e)
            })), l - 1) : (await n((() => N((() => M(r)))), r.delay), e)
        };
    return function(e, r={}) {
        let N = async (e, t, n=!1) => {
                J.frozen && await new Promise((e => {
                    this.unfreeze = () => {
                        J.frozen = !1,
                        e()
                    }
                })),
                n || await X.beforeStep(this),
                await (async (e, t, n) => new Promise((r => {
                    n.push(setTimeout((async () => {
                        await e(),
                        r()
                    }), t || 0))
                })))(e, t, Q),
                n || await X.afterStep(this)
            },
            M = () => m(_),
            x = (e=0) => function(e) {
                let {speed: t, deleteSpeed: n, lifeLike: r} = e;
                return n = null !== n ? n : t / 3, r ? [y(t, p(t)), y(n, p(n))] : [t, n]
            }(X)[e],
            $ = () => (e => m(e) ? n(e.value) : u(e, !0).filter((e => !(e.childNodes.length > 0))))(_),
            C = (e, t) => (G.add(e), ((e={}) => {
                let t = e.delay;
                t && G.add({
                    delay: t
                })
            })(t), this),
            I = () => null != W ? W : U,
            k = (e={}) => [{
                func: () => R(e)
            }, {
                func: () => R(X)
            }],
            H = e => {
                let t = X.nextStringDelay;
                G.add([{
                    delay: t[0]
                }, ...e, {
                    delay: t[1]
                }])
            },
            A = async () => {
                !M() && Z && _.appendChild(Z),
                K && ((e, t, n) => {
                    let r = `[data-typeit-id='${e}'] .ti-cursor`,
                        i = getComputedStyle(n),
                        l = Object.entries(S).reduce(((e, [t, n]) => `${e} ${t}: var(--ti-cursor-${t}, ${n || i[t]});`), "");
                    f(`@keyframes blink-${e} { 0% {opacity: 0} 49% {opacity: 0} 50% {opacity: 1} } ${r} { display: inline; letter-spacing: -1em; ${l} animation: blink-${e} ${t.cursorSpeed / 1e3}s infinite; } ${r}.with-delay { animation-delay: 500ms; } ${r}.disabled { animation: none; }`, e)
                })(Y, X, _)
            },
            P = e => {
                K && Z && (Z.classList.toggle("disabled", e), Z.classList.toggle("with-delay", !e))
            },
            z = () => {
                let e = X.strings.filter((e => !!e));
                e.forEach(((t, n) => {
                    if (this.type(t), n + 1 === e.length)
                        return;
                    let r = X.breakLines ? [{
                        func: () => F(c("BR")),
                        typeable: !0
                    }] : E({
                        func: V,
                        delay: x(1)
                    }, G.getTypeable().length);
                    H(r)
                }))
            },
            O = async (e=!0) => {
                J.started = !0;
                let t = t => {
                    P(!1),
                    G.done(t, !e)
                };
                try {
                    let n = [...G.getQueue()];
                    for (let e = 0; e < n.length; e++) {
                        let [r, i] = n[e];
                        if (!i.done) {
                            if (i.typeable && !J.frozen && P(!0), !i.deletable || i.deletable && $().length) {
                                let r = await D(e, n, N);
                                Array(r - e).fill(e + 1).map(((e, t) => e + t)).forEach((e => {
                                    let [r] = n[e];
                                    t(r)
                                })),
                                e = r
                            }
                            t(r)
                        }
                    }
                    if (!e)
                        return this;
                    if (J.completed = !0, await X.afterComplete(this), !X.loop)
                        throw "";
                    let r = X.loopDelay;
                    N((async () => {
                        await (async e => {
                            let t = I();
                            t && await B({
                                value: t
                            });
                            for (let n of $())
                                await N(V, x(1));
                            G.reset(),
                            G.set(0, {
                                delay: e
                            })
                        })(r[0]),
                        O()
                    }), r[1])
                } catch (n) {}
                return this
            },
            B = async e => {
                var t,
                    n,
                    r;
                t = e,
                n = U,
                r = $(),
                U = Math.min(Math.max(n + t, 0), r.length),
                ((e, t, n) => {
                    let r = t[n - 1],
                        i = v(".ti-cursor", e);
                    (e = (null == r ? void 0 : r.parentNode) || e).insertBefore(i, r || null)
                })(_, $(), U)
            },
            F = e => ((e, t) => {
                if (m(e))
                    return void (e.value = `${e.value}${t.textContent}`);
                t.innerHTML = "";
                let n = "BODY" === (null == (r = t.originalParent) ? void 0 : r.tagName) ? e : t.originalParent || e;
                var r;
                n.insertBefore(t, v(".ti-cursor", n) || null)
            })(_, e),
            R = async e => X = w(X, e),
            q = async () => {
                M() ? _.value = "" : $().forEach(T)
            },
            V = () => {
                let e = $();
                e.length && (M() ? _.value = _.value.slice(0, -1) : T(e[U]))
            };
        this.break = function(e) {
            return C({
                func: () => F(c("BR")),
                typeable: !0
            }, e)
        },
        this.delete = function(e=null, t={}) {
            e = g(e);
            let n = k(t),
                r = e,
                {instant: i, to: l} = t,
                a = G.getTypeable(),
                o = null === r ? a.length : b(r) ? r : L({
                    queueItems: a,
                    selector: r,
                    cursorPosition: I(),
                    to: l
                });
            return C([n[0], ...E({
                func: V,
                delay: i ? 0 : x(1),
                deletable: !0
            }, o), n[1]], t)
        },
        this.empty = function(e={}) {
            return C({
                func: q
            }, e)
        },
        this.exec = function(e, t={}) {
            let n = k(t);
            return C([n[0], {
                func: () => e(this)
            }, n[1]], t)
        },
        this.move = function(e, t={}) {
            e = g(e);
            let n = k(t),
                {instant: r, to: i} = t,
                l = L({
                    queueItems: G.getTypeable(),
                    selector: null === e ? "" : e,
                    to: i,
                    cursorPosition: I()
                }),
                a = l < 0 ? -1 : 1;
            return W = I() + l, C([n[0], ...E({
                func: () => B(a),
                delay: r ? 0 : x()
            }, Math.abs(l)), n[1]], t)
        },
        this.options = function(e, t={}) {
            return e = g(e), R(e), C({}, t)
        },
        this.pause = function(e, t={}) {
            return C({
                delay: g(e)
            }, t)
        },
        this.type = function(e, t={}) {
            e = g(e);
            let {instant: n} = t,
                r = k(t),
                i = d(e, X.html).map((e => {
                    return {
                        func: () => F(e),
                        char: e,
                        delay: n || (t = e, /<(.+)>(.*?)<\/(.+)>/.test(t.outerHTML)) ? 0 : x(),
                        typeable: e.nodeType === Node.TEXT_NODE
                    };
                    var t
                })),
                l = [r[0], {
                    func: async () => await X.beforeString(e, this)
                }, ...i, {
                    func: async () => await X.afterString(e, this)
                }, r[1]];
            return C(l, t)
        },
        this.is = function(e) {
            return J[e]
        },
        this.destroy = function(e=!0) {
            Q.forEach(clearTimeout),
            Q = [],
            g(e) && Z && T(Z),
            J.destroyed = !0
        },
        this.freeze = function() {
            J.frozen = !0
        },
        this.unfreeze = () => {},
        this.reset = function(e) {
            !this.is("destroyed") && this.destroy(),
            e ? (G.wipe(), e(this)) : G.reset(),
            U = 0;
            for (let t in J)
                J[t] = !1;
            return _[M() ? "value" : "innerHTML"] = "", this
        },
        this.go = function() {
            return J.started ? this : (A(), X.waitUntilVisible ? (((e, t) => {
                new IntersectionObserver(((n, r) => {
                    n.forEach((n => {
                        n.isIntersecting && (t(), r.unobserve(e))
                    }))
                }), {
                    threshold: 1
                }).observe(e)
            })(_, O.bind(this)), this) : (O(), this))
        },
        this.flush = function(e=(() => {})) {
            return A(), O(!1).then(e), this
        },
        this.getQueue = () => G,
        this.getOptions = () => X,
        this.updateOptions = e => R(e),
        this.getElement = () => _;
        let _ = "string" == typeof (j = e) ? v(j) : j;
        var j;
        let Q = [],
            U = 0,
            W = null,
            J = w({}, o),
            X = w(s, r);
        X = w(X, {
            html: !M() && X.html,
            nextStringDelay: h(X.nextStringDelay),
            loopDelay: h(X.loopDelay)
        });
        let Y = Math.random().toString().substring(2, 9),
            G = function(e) {
                let n = function(e) {
                        return t(e).forEach((e => {
                            var t;
                            return i.set(Symbol(null == (t = e.char) ? void 0 : t.innerText), {
                                ...e
                            })
                        })), this
                    },
                    r = () => Array.from(i.values()),
                    i = new Map;
                return n(e), {
                    add: n,
                    set: function(e, t) {
                        let n = [...i.keys()];
                        i.set(n[e], t)
                    },
                    wipe: function() {
                        i = new Map,
                        n(e)
                    },
                    reset: function() {
                        i.forEach((e => delete e.done))
                    },
                    destroy: e => i.delete(e),
                    done: (e, t=!1) => t ? i.delete(e) : i.get(e).done = !0,
                    getItems: (e=!1) => e ? r() : r().filter((e => !e.done)),
                    getQueue: () => i,
                    getTypeable: () => r().filter((e => e.typeable))
                }
            }([{
                func: () => {},
                delay: X.startDelay
            }]);
        _.dataset.typeitId = Y,
        f("[data-typeit-id]:before {content: '.'; display: inline-block; width: 0; visibility: hidden;}");
        let K = X.cursor && !M(),
            Z = (() => {
                if (M())
                    return;
                let e = c("span");
                return e.className = a, K ? (e.innerHTML = l(X.cursorChar).innerHTML, e) : (e.style.visibility = "hidden", e)
            })();
        X.strings = (e => {
            let t = _.innerHTML;
            return t ? (_.innerHTML = "", X.startDelete ? (_.innerHTML = t, i(_), H(E({
                func: V,
                delay: x(1),
                deletable: !0
            }, $().length)), e) : t.replace(/<!--(.+?)-->/g, "").trim().split(/<br(?:\s*?)(?:\/)?>/).concat(e)) : e
        })(t(X.strings)),
        X.strings.length && z()
    }
}));
